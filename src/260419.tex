\subsection{26.04.19}
\subsubsection{Задача о распределении ресурсов.}
Нужно БООООЛЬШЕ золота!!! (с) Послушник, Нежить, Warcraft III\\
Замечание: хотя "монеты" и "единицы древесины" звучат как целые числа, быть таковыми они не обязаны,.\\
Итак, пусть у нас есть $x_1$ единиц некого ресурса (допустим, древесины), и у нас есть два способа его вложить.\\
Допустим, первый способ - вложиться в найм послушников, и на это мы потратим $0 \leq y_1 \leq x_1$ древесины (Урфин Джюс передает пламенный привет), заработав $g(y_1)$ монет.\\
Второй способ - вложиться в постройку зиккурата, потратив на это оставшиеся $x_1 - y_1$ единиц древесины, и получив $h(x_1 - y_1)$ монет прибыли.\\
Также, (только в ООО "Нер'Зул-банк") мы получаем "кэшбек" с потраченной древесины - $\alpha y_1$ единиц с $y_1$ единиц, потраченных на первый способ и $\beta(x_1 - y_1)$ со второго способа ($0 \leq \alpha, \beta \leq 1$)\\
Таким образом, мы имеем выигрыш в $R_1(x_1, y_1) = g(y_1) + h(x_1 - y_1)$ заработанных монет и $x_2 = \alpha y_1 + \beta (x_1 - y_1)$ "переработанных" (Король-Лич за окружающую среду! Остановим глобальное потепление - спасем ледники Ледяной Короны!) единиц дерева в остатке.\\
Максимизировать (выбором $y_1$ при фиксированном $x_1$) $R_1(x_1, y_1)$ не очень сложно.\\
Теперь имеющиеся $x_2$ единиц древесины можно снова вложить, получив суммарно:\\
$R_2(x_1, y_1, y_2) = g(y_1) + h(x_1 - y_1) + g(y_2) + h(x_2 - y_2)$ монет и \\
$x_3 = \alpha y_2 + \beta (x_2 - y_2)$ единиц дерева в остатке.\\
Максимизировать $R_2(x_1, y_1, y_2)$ уже сложнее.\\
Теперь посмотрим на n шагов:\\
$R_n(x_1, y_1, ..., y_n) = \sum\limits_{i = 1}^n(g(y_i) + h(x_i - y_i)$.\\
Максимизировать $R_n(x_1, y_1, ..., y_n)$ это уже совсем сложно.\\
Назовем оптимальной такую стратегию (а что такое вообще стратегия? Формализуем в следующем пункте, пока будем понимать интуитивно), которая максимизирует $R_n(x_1, y_1, ..., y_n)$\\
Введем функцию $f_n(x) = \max\limits_{0 \leq y_i \leq x_i}R_n(x_1 = x, y_1, ..., y_n)$\\
Однако, как ее считать - непонятно.\\
Рассмотрим ситуацию, когда у нас $x$ единиц древесины.\\
Если мы выбрали значение $y$, то к выигрышу прибавляется $g(y) + h(x - y)$ монет, а мы переходим в ситуацию, когда у нас $x'$ единиц древесины.\\
Функцию $f_1(x)$ найти просто, ведь она одномерная.\\
Заметим, что используя этот результат, мы можем сделать $f_2(x)$ одномерной, так как $f_2(x) = \max\limits_{0 \leq y_1 \leq x_1}(g(y_1) + h(x_1 - y_1) + f_1(x_2))$.\\
Продолжая этот процесс для $f_3, ..., f_n$, мы свели одну сложную n-мерную задачу к совокупности n простых одномерных задач.\\
Сведение задач к более простым подзадачам - главный принцип динамического программирования.
\subsubsection{Динамическое программирование}
Термин был введен Беллманом еще во время WWII, когда никаких компьютеров еще особо не было, и термин "programming" означал "управление". Слово "динамическое" было вообще добавлено исключительно для того, чтобы итоговая тема исследований, с одной стороны, звучала внушительно (чтобы получить финансирование), а с другой - безобидно (и Беллмана не упихали в секретку и не припрягли к ядерному проекту). Короче, динамическое программирование похоже на морскую свинку, ведь морская свинка  - не морская и не свинка.\\
Стоит также учитывать, что динамическое программирование - не очень строгая область, где теория в основном направляет интуицию, а не задает четкие рамки.\\
Динамическое программирование рассматривает класс задач, когда есть некая физическая система, состояние которой в каждый момент времени описывается M переменными $p = (p_1, ... , p_M)$, которые называют фазовыми переменными.\\
$p \in D$, где D - фазовое пространство (примечание: возможно, дурацкое слово "фазовый" возникло при попытке перевода неизвестным надмозгом слова "phase", которое в данной ситуации стоило перевести как "этап, стадия". Хотя, за название переменных "этапными" в то время можно было, наверно, и самому попасть на этап...).\\
$\{T_k\}_{k \in I}$, где I - индексное множество, называется семейством управлений, если $\forall k \in I, p \in D \; T_k(p) \in D$.\\
Стратегия - выбор последовательности (допустимых) управлений.\\
p - начальное состояние, $p_1 = T_{i_1}(p)$, $p_2 = T_{i_2}(p_1)$ и.т.д.\\
$f_n(p) = \max\limits_{T}R(p_n)$. Стратегия, максимизирующая эту функцию, называется максимальной.\\
Соотношение $f_n(p) = \max\limits_{i_1 \in I}f_{n - 1}(T_{i_1}(p))$ называется основным рекурсивным соотношением.\\
WARNING: многабукаф, нестрого, слишком сложно, до свидания.\\
Принцип оптимальности: оптимальная стратегия характеризуется тем, что независимо от начального состояния p и выбора первого управления, дальнейший набор управлений обеспечивает оптимальное поведение относительно состояния, в которое система пришла после первого управления.
\subsubsection{Задача о размене.}
$v_1, ... , v_n$ - достоинства монет, монет каждого вида бесконечно много. X - сумма, которую нужно набрать, используя наименьшее число монет.\\
Текущее состояние - сумма, которую осталось набрать.\\
Управления - $T_i(x) = x - v_i$.\\
$f(x)$ - наименьшее число монет, которыми можно набрать сумму x.\\
$f(x) = \min\limits_{i \in 1..n}(f(x - v_i) + 1)$.\\
$f(0) = 0$.\\
